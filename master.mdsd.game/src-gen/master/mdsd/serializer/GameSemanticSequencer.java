/*
 * generated by Xtext 2.10.0
 */
package master.mdsd.serializer;

import com.google.inject.Inject;
import java.util.Set;
import master.mdsd.game.A;
import master.mdsd.game.Ammo;
import master.mdsd.game.AttS;
import master.mdsd.game.Attack;
import master.mdsd.game.Attribute;
import master.mdsd.game.AttributeAttack;
import master.mdsd.game.AttributeInitializer;
import master.mdsd.game.BooleanExpression;
import master.mdsd.game.Bullet;
import master.mdsd.game.CharDec;
import master.mdsd.game.CharType;
import master.mdsd.game.CharacterAttr;
import master.mdsd.game.Condition;
import master.mdsd.game.D;
import master.mdsd.game.EQ;
import master.mdsd.game.Expression;
import master.mdsd.game.GT;
import master.mdsd.game.GTE;
import master.mdsd.game.GameMap;
import master.mdsd.game.GamePackage;
import master.mdsd.game.Initializer;
import master.mdsd.game.IntLiteral;
import master.mdsd.game.LT;
import master.mdsd.game.LTE;
import master.mdsd.game.Location;
import master.mdsd.game.M;
import master.mdsd.game.Model;
import master.mdsd.game.Operation;
import master.mdsd.game.Pathfinding;
import master.mdsd.game.ReferenceCharacter;
import master.mdsd.game.T;
import master.mdsd.game.TargetRef;
import master.mdsd.game.Type;
import master.mdsd.game.VECTOR;
import master.mdsd.services.GameGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GameSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GameGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GamePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GamePackage.A:
				sequence_LogicOperator(context, (A) semanticObject); 
				return; 
			case GamePackage.ACTION:
				sequence_Action(context, (master.mdsd.game.Action) semanticObject); 
				return; 
			case GamePackage.AMMO:
				sequence_AttributeTypeAttack(context, (Ammo) semanticObject); 
				return; 
			case GamePackage.ATT_S:
				sequence_AttributeTypeAttack(context, (AttS) semanticObject); 
				return; 
			case GamePackage.ATTACK:
				sequence_Attack(context, (Attack) semanticObject); 
				return; 
			case GamePackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case GamePackage.ATTRIBUTE_ATTACK:
				sequence_AttributeAttack(context, (AttributeAttack) semanticObject); 
				return; 
			case GamePackage.ATTRIBUTE_INITIALIZER:
				sequence_AttributeInitializer(context, (AttributeInitializer) semanticObject); 
				return; 
			case GamePackage.BOOLEAN_EXPRESSION:
				sequence_BooleanExpression(context, (BooleanExpression) semanticObject); 
				return; 
			case GamePackage.BULLET:
				if (rule == grammarAccess.getAttributeTypeAttackRule()) {
					sequence_AttributeTypeAttack(context, (Bullet) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEntityRule()
						|| rule == grammarAccess.getDynamicEntityRule()
						|| rule == grammarAccess.getBehaviourRule()
						|| rule == grammarAccess.getBulletRule()) {
					sequence_Bullet(context, (Bullet) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.CHAR_DEC:
				sequence_CharDec(context, (CharDec) semanticObject); 
				return; 
			case GamePackage.CHAR_TYPE:
				sequence_CharType(context, (CharType) semanticObject); 
				return; 
			case GamePackage.CHARACTER:
				sequence_Character(context, (master.mdsd.game.Character) semanticObject); 
				return; 
			case GamePackage.CHARACTER_ATTR:
				sequence_CharacterAttr(context, (CharacterAttr) semanticObject); 
				return; 
			case GamePackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case GamePackage.D:
				sequence_LogicOperator(context, (D) semanticObject); 
				return; 
			case GamePackage.EQ:
				sequence_CompOperator(context, (EQ) semanticObject); 
				return; 
			case GamePackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case GamePackage.GT:
				sequence_CompOperator(context, (GT) semanticObject); 
				return; 
			case GamePackage.GTE:
				sequence_CompOperator(context, (GTE) semanticObject); 
				return; 
			case GamePackage.GAME_MAP:
				sequence_GameMap(context, (GameMap) semanticObject); 
				return; 
			case GamePackage.INITIALIZER:
				sequence_Initializer(context, (Initializer) semanticObject); 
				return; 
			case GamePackage.INT_LITERAL:
				sequence_TerminalExpression(context, (IntLiteral) semanticObject); 
				return; 
			case GamePackage.LT:
				sequence_CompOperator(context, (LT) semanticObject); 
				return; 
			case GamePackage.LTE:
				sequence_CompOperator(context, (LTE) semanticObject); 
				return; 
			case GamePackage.LOCATION:
				sequence_Location(context, (Location) semanticObject); 
				return; 
			case GamePackage.M:
				sequence_LogicOperator(context, (M) semanticObject); 
				return; 
			case GamePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case GamePackage.OBJECT:
				sequence_Object(context, (master.mdsd.game.Object) semanticObject); 
				return; 
			case GamePackage.OPERATION:
				sequence_Expression(context, (Operation) semanticObject); 
				return; 
			case GamePackage.PATHFINDING:
				sequence_Pathfinding(context, (Pathfinding) semanticObject); 
				return; 
			case GamePackage.REFERENCE_CHARACTER:
				sequence_ReferenceCharacter(context, (ReferenceCharacter) semanticObject); 
				return; 
			case GamePackage.T:
				sequence_LogicOperator(context, (T) semanticObject); 
				return; 
			case GamePackage.TARGET_REF:
				sequence_TargetRef(context, (TargetRef) semanticObject); 
				return; 
			case GamePackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case GamePackage.VECTOR:
				sequence_VECTOR(context, (VECTOR) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (charAtt=CharacterAttr charDec=CharDec? (op=LogicOperator? ex=Expression)?)
	 */
	protected void sequence_Action(ISerializationContext context, master.mdsd.game.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Attack
	 *     DynamicEntity returns Attack
	 *     Behaviour returns Attack
	 *     Attack returns Attack
	 *
	 * Constraint:
	 *     (entityid='Attack' name=ID attributes+=Attribute* attributesAttack+=AttributeAttack* rules+=Condition?)
	 */
	protected void sequence_Attack(ISerializationContext context, Attack semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeAttack returns AttributeAttack
	 *
	 * Constraint:
	 *     (attributeTypesAttack+=AttributeTypeAttack type+=Type?)
	 */
	protected void sequence_AttributeAttack(ISerializationContext context, AttributeAttack semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeInitializer returns AttributeInitializer
	 *
	 * Constraint:
	 *     (attributeId=ID amountValueId=INT? target=TargetRef)
	 */
	protected void sequence_AttributeInitializer(ISerializationContext context, AttributeInitializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeTypeAttack returns Ammo
	 *
	 * Constraint:
	 *     {Ammo}
	 */
	protected void sequence_AttributeTypeAttack(ISerializationContext context, Ammo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeTypeAttack returns AttS
	 *
	 * Constraint:
	 *     {AttS}
	 */
	protected void sequence_AttributeTypeAttack(ISerializationContext context, AttS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeTypeAttack returns Bullet
	 *
	 * Constraint:
	 *     bulletRef=[Bullet|ID]
	 */
	protected void sequence_AttributeTypeAttack(ISerializationContext context, Bullet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BULLET__BULLET_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BULLET__BULLET_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeTypeAttackAccess().getBulletRefBulletIDTerminalRuleCall_2_2_0_1(), semanticObject.getBulletRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (attributename=ID type=Type)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.ATTRIBUTE__ATTRIBUTENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.ATTRIBUTE__ATTRIBUTENAME));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.ATTRIBUTE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.ATTRIBUTE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getAttributenameIDTerminalRuleCall_1_0(), semanticObject.getAttributename());
		feeder.accept(grammarAccess.getAttributeAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns BooleanExpression
	 *
	 * Constraint:
	 *     (
	 *         attributeRefLeft=CharacterAttr? 
	 *         leftEx=Expression? 
	 *         operator=CompOperator 
	 *         attributeRefRight=CharacterAttr? 
	 *         (op=LogicOperator? rightEx=Expression)?
	 *     )
	 */
	protected void sequence_BooleanExpression(ISerializationContext context, BooleanExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Bullet
	 *     DynamicEntity returns Bullet
	 *     Behaviour returns Bullet
	 *     Bullet returns Bullet
	 *
	 * Constraint:
	 *     (entityid='Bullet' name=ID attributesBullet+=Attribute*)
	 */
	protected void sequence_Bullet(ISerializationContext context, Bullet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CharDec returns CharDec
	 *
	 * Constraint:
	 *     (charAttResult=CharacterAttr | val=INTORDEC)
	 */
	protected void sequence_CharDec(ISerializationContext context, CharDec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CharType returns CharType
	 *
	 * Constraint:
	 *     charTypeId=ID
	 */
	protected void sequence_CharType(ISerializationContext context, CharType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.CHAR_TYPE__CHAR_TYPE_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.CHAR_TYPE__CHAR_TYPE_ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharTypeAccess().getCharTypeIdIDTerminalRuleCall_0(), semanticObject.getCharTypeId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CharacterAttr returns CharacterAttr
	 *
	 * Constraint:
	 *     (reference=ReferenceCharacter attributename=ID)
	 */
	protected void sequence_CharacterAttr(ISerializationContext context, CharacterAttr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.CHARACTER_ATTR__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.CHARACTER_ATTR__REFERENCE));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.CHARACTER_ATTR__ATTRIBUTENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.CHARACTER_ATTR__ATTRIBUTENAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharacterAttrAccess().getReferenceReferenceCharacterParserRuleCall_0_0(), semanticObject.getReference());
		feeder.accept(grammarAccess.getCharacterAttrAccess().getAttributenameIDTerminalRuleCall_1_0(), semanticObject.getAttributename());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Character
	 *     DynamicEntity returns Character
	 *     Character returns Character
	 *
	 * Constraint:
	 *     (entityid='Character' charId=CharType name=ID att+=Attribute*)
	 */
	protected void sequence_Character(ISerializationContext context, master.mdsd.game.Character semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompOperator returns EQ
	 *
	 * Constraint:
	 *     op='='
	 */
	protected void sequence_CompOperator(ISerializationContext context, EQ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.COMP_OPERATOR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.COMP_OPERATOR__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompOperatorAccess().getOpEqualsSignKeyword_4_1_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompOperator returns GT
	 *
	 * Constraint:
	 *     op='>'
	 */
	protected void sequence_CompOperator(ISerializationContext context, GT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.COMP_OPERATOR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.COMP_OPERATOR__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompOperatorAccess().getOpGreaterThanSignKeyword_1_1_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompOperator returns GTE
	 *
	 * Constraint:
	 *     op='>='
	 */
	protected void sequence_CompOperator(ISerializationContext context, GTE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.COMP_OPERATOR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.COMP_OPERATOR__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompOperatorAccess().getOpGreaterThanSignEqualsSignKeyword_3_1_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompOperator returns LT
	 *
	 * Constraint:
	 *     op='<'
	 */
	protected void sequence_CompOperator(ISerializationContext context, LT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.COMP_OPERATOR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.COMP_OPERATOR__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompOperatorAccess().getOpLessThanSignKeyword_0_1_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompOperator returns LTE
	 *
	 * Constraint:
	 *     op='<='
	 */
	protected void sequence_CompOperator(ISerializationContext context, LTE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.COMP_OPERATOR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.COMP_OPERATOR__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompOperatorAccess().getOpLessThanSignEqualsSignKeyword_2_1_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (ifCondition=BooleanExpression then=Action elseIfCondition=Condition?)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     Expression.Operation_1_0 returns Expression
	 *     TerminalExpression returns Expression
	 *
	 * Constraint:
	 *     tm=TerminalExpression
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.EXPRESSION__TM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.EXPRESSION__TM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getTmTerminalExpressionParserRuleCall_0_0(), semanticObject.getTm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Operation
	 *     Expression.Operation_1_0 returns Operation
	 *     TerminalExpression returns Operation
	 *
	 * Constraint:
	 *     (left=Expression_Operation_1_0 op=LogicOperator right=TerminalExpression)
	 */
	protected void sequence_Expression(ISerializationContext context, Operation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OPERATION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OPERATION__OP));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getOperationLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getOpLogicOperatorParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getExpressionAccess().getRightTerminalExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GameMap returns GameMap
	 *     Entity returns GameMap
	 *     StaticEntity returns GameMap
	 *
	 * Constraint:
	 *     (entityId='Map' attributeList+=Attribute*)
	 */
	protected void sequence_GameMap(ISerializationContext context, GameMap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Initializer
	 *     StaticEntity returns Initializer
	 *     Initializer returns Initializer
	 *
	 * Constraint:
	 *     (entityId='Initializer' attributesInitializer+=AttributeInitializer*)
	 */
	protected void sequence_Initializer(ISerializationContext context, Initializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Location returns Location
	 *
	 * Constraint:
	 *     (locationId='random' | (typea=Type typeb=Type))
	 */
	protected void sequence_Location(ISerializationContext context, Location semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicOperator returns A
	 *
	 * Constraint:
	 *     lop='+'
	 */
	protected void sequence_LogicOperator(ISerializationContext context, A semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.LOGIC_OPERATOR__LOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.LOGIC_OPERATOR__LOP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicOperatorAccess().getLopPlusSignKeyword_1_1_0(), semanticObject.getLop());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicOperator returns D
	 *
	 * Constraint:
	 *     lop='/'
	 */
	protected void sequence_LogicOperator(ISerializationContext context, D semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.LOGIC_OPERATOR__LOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.LOGIC_OPERATOR__LOP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicOperatorAccess().getLopSolidusKeyword_3_1_0(), semanticObject.getLop());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicOperator returns M
	 *
	 * Constraint:
	 *     lop='-'
	 */
	protected void sequence_LogicOperator(ISerializationContext context, M semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.LOGIC_OPERATOR__LOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.LOGIC_OPERATOR__LOP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicOperatorAccess().getLopHyphenMinusKeyword_2_1_0(), semanticObject.getLop());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicOperator returns T
	 *
	 * Constraint:
	 *     lop='*'
	 */
	protected void sequence_LogicOperator(ISerializationContext context, T semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.LOGIC_OPERATOR__LOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.LOGIC_OPERATOR__LOP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicOperatorAccess().getLopAsteriskKeyword_0_1_0(), semanticObject.getLop());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     entities+=Entity*
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Object
	 *     DynamicEntity returns Object
	 *     Object returns Object
	 *
	 * Constraint:
	 *     (entityid='Object' name=ID att+=Attribute*)
	 */
	protected void sequence_Object(ISerializationContext context, master.mdsd.game.Object semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Pathfinding
	 *     DynamicEntity returns Pathfinding
	 *     Behaviour returns Pathfinding
	 *     Pathfinding returns Pathfinding
	 *
	 * Constraint:
	 *     (entityid='Pathfinding' name=ID attPathfinding+=Attribute* conditions+=Condition*)
	 */
	protected void sequence_Pathfinding(ISerializationContext context, Pathfinding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceCharacter returns ReferenceCharacter
	 *
	 * Constraint:
	 *     (characterId=[Character|ID] | targetId='self')
	 */
	protected void sequence_ReferenceCharacter(ISerializationContext context, ReferenceCharacter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TargetRef returns TargetRef
	 *
	 * Constraint:
	 *     (targetId=ID locationsId+=Location locationsId+=Location*)
	 */
	protected void sequence_TargetRef(ISerializationContext context, TargetRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TerminalExpression returns IntLiteral
	 *
	 * Constraint:
	 *     value=INTORDEC
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExpressionAccess().getValueINTORDECParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (valueId=INTORDEC | valueId=ID | valueIdVec=VECTOR)
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VECTOR returns VECTOR
	 *
	 * Constraint:
	 *     (xVal=INTORDEC yVal=INTORDEC)
	 */
	protected void sequence_VECTOR(ISerializationContext context, VECTOR semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.VECTOR__XVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.VECTOR__XVAL));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.VECTOR__YVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.VECTOR__YVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVECTORAccess().getXValINTORDECParserRuleCall_0_0(), semanticObject.getXVal());
		feeder.accept(grammarAccess.getVECTORAccess().getYValINTORDECParserRuleCall_1_0(), semanticObject.getYVal());
		feeder.finish();
	}
	
	
}
